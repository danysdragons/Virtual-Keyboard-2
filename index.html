<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Virtual Keyboard ‚Äî 4 Octaves ‚Ä¢ Modes ‚Ä¢ Instruments ‚Ä¢ Pure Tones</title>
  <style>
    :root{
      --white-w: 48px;   /* width of white keys */
      --white-h: 200px;  /* height of white keys */
      --black-w: 30px;   /* width of black keys */
      --black-h: 120px;  /* height of black keys */
      --active: #5cc6ff;

      --bg: #0b0e11;
      --text: #eaeef2;
      --muted-text: #c9d4df;
      --small-text: #94a6b7;
      --panel-bg: #12171c;
      --panel-border: #1b232c;
      --panel-shadow: 0 1px 0 #000 inset, 0 0 0 1px #1b232c;
      --control-bg: #0e1318;
      --control-border: #1b232c;
      --control-text: hsl(210, 39%, 93%);
      --control-strong-bg: #0f1720;
      --control-strong-border: #2a3a4a;
      --control-strong-shadow: 0 0 0 1px #2a3a4a, 0 2px 6px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.03);
      --kbd-wrap-bg: #0e1318;
      --kbd-wrap-border: #1b232c;
      --kbd-wrap-shadow: 0 1px 0 #000 inset, 0 0 0 1px #1b232c;
      --banner-bg: linear-gradient(90deg, #1e2937, #18212b);
      --banner-border: #2a3a4a;
      --banner-text: #cfe8ff;
      --banner-strong: #8fceff;
      --btn-bg: #0f1720;
      --btn-border: #2a3a4a;
      --pill-border: #233141;
      --pill-text: #a8b8c8;
      --log-bg: #0e1318;
      --log-border: #1b232c;
      --row-icon-bg: #0f1720;
      --row-icon-border: #2a3a4a;
      --row-icon-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);

      --white-top: #f7fbff;
      --white-bottom: #e4ecf4;
      --white-border: #a3b3c4;
      --white-border-bottom: #7a8b9c;
      --white-label: #2a3c4d;
      --white-active-top: #e8f6ff;
      --white-active-bottom: #dfefff;

      --black-top: #0c0f14;
      --black-bottom: #1b232c;
      --black-border: #0b0f14;
      --black-border-bottom: #000;
      --black-label: #d9e7f5;
      --black-active-top: #121923;
      --black-active-bottom: #263243;
      --black-shadow: inset 0 -4px 0 rgba(255,255,255,0.06), 0 6px 10px rgba(0,0,0,0.35);

      --scale-dot-white: #3fb2ff;
      --scale-dot-white-shadow: 0 0 0 1px rgba(0,0,0,0.25);
      --scale-dot-black: #7fd1ff;
      --scale-dot-black-shadow: 0 0 0 1px rgba(255,255,255,0.6);
    }
    :root[data-theme="solarized-dark"]{
      --active: #268bd2;
      --bg: #002b36;
      --text: #dbe7e8;
      --muted-text: #93a1a1;
      --small-text: #839496;
      --panel-bg: #073642;
      --panel-border: #0b3b45;
      --panel-shadow: 0 1px 0 #00212a inset, 0 0 0 1px #0b3b45;
      --control-bg: #073642;
      --control-border: #0b3b45;
      --control-text: #e7f0ef;
      --control-strong-bg: #0b3b45;
      --control-strong-border: #1c4b55;
      --control-strong-shadow: 0 0 0 1px #1c4b55, 0 2px 6px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.04);
      --kbd-wrap-bg: #073642;
      --kbd-wrap-border: #0b3b45;
      --kbd-wrap-shadow: 0 1px 0 #00212a inset, 0 0 0 1px #0b3b45;
      --banner-bg: linear-gradient(90deg, #0b3b45, #0a2f3a);
      --banner-border: #1c4b55;
      --banner-text: #d6e3e3;
      --banner-strong: #b7e3dc;
      --btn-bg: #0b3b45;
      --btn-border: #1c4b55;
      --pill-border: #1c4b55;
      --pill-text: #aab9b9;
      --log-bg: #073642;
      --log-border: #0b3b45;
      --row-icon-bg: #0b3b45;
      --row-icon-border: #1c4b55;
      --row-icon-shadow: inset 0 0 0 1px rgba(255,255,255,0.07);

      --white-top: #fdf6e3;
      --white-bottom: #eee8d5;
      --white-border: #c2b79b;
      --white-border-bottom: #8a7f66;
      --white-label: #4c5458;
      --white-active-top: #fff5d6;
      --white-active-bottom: #f1e4c4;

      --black-top: #0f2f39;
      --black-bottom: #0b3b45;
      --black-border: #082730;
      --black-border-bottom: #00161c;
      --black-label: #dfecec;
      --black-active-top: #114853;
      --black-active-bottom: #0f3d47;
      --black-shadow: inset 0 -4px 0 rgba(255,255,255,0.05), 0 6px 10px rgba(0,0,0,0.4);

      --scale-dot-white: #2aa198;
      --scale-dot-white-shadow: 0 0 0 1px rgba(0,0,0,0.25);
      --scale-dot-black: #268bd2;
      --scale-dot-black-shadow: 0 0 0 1px rgba(255,255,255,0.55);
    }
    :root[data-theme="solarized-light"]{
      --active: #268bd2;
      --bg: #fdf6e3;
      --text: #586e75;
      --muted-text: #657b83;
      --small-text: #839496;
      --panel-bg: #eee8d5;
      --panel-border: #d4c6a5;
      --panel-shadow: 0 1px 0 #d6cdb6 inset, 0 0 0 1px #d4c6a5;
      --control-bg: #f4efe0;
      --control-border: #d4c6a5;
      --control-text: #2f3b40;
      --control-strong-bg: #e8dfc9;
      --control-strong-border: #cdbf9c;
      --control-strong-shadow: 0 0 0 1px #cdbf9c, 0 2px 6px rgba(88,110,117,0.2), inset 0 0 0 1px rgba(255,255,255,0.35);
      --kbd-wrap-bg: #f4efe0;
      --kbd-wrap-border: #d4c6a5;
      --kbd-wrap-shadow: 0 1px 0 #d6cdb6 inset, 0 0 0 1px #d4c6a5;
      --banner-bg: linear-gradient(90deg, #efe6cf, #e8dcc1);
      --banner-border: #cdbf9c;
      --banner-text: #4c5b62;
      --banner-strong: #b58900;
      --btn-bg: #e8dfc9;
      --btn-border: #cdbf9c;
      --pill-border: #cdbf9c;
      --pill-text: #6c7b80;
      --log-bg: #f4efe0;
      --log-border: #d4c6a5;
      --row-icon-bg: #e8dfc9;
      --row-icon-border: #cdbf9c;
      --row-icon-shadow: inset 0 0 0 1px rgba(255,255,255,0.4);

      --white-top: #fffdf6;
      --white-bottom: #f6f1e3;
      --white-border: #b7a98b;
      --white-border-bottom: #7f715d;
      --white-label: #4c5b62;
      --white-active-top: #fff3d8;
      --white-active-bottom: #f7e6c5;

      --black-top: #2b3a3f;
      --black-bottom: #1f2a2e;
      --black-border: #1b2428;
      --black-border-bottom: #0f171a;
      --black-label: #e8efe9;
      --black-active-top: #34484e;
      --black-active-bottom: #2a3c40;
      --black-shadow: inset 0 -4px 0 rgba(255,255,255,0.04), 0 6px 10px rgba(0,0,0,0.25);

      --scale-dot-white: #268bd2;
      --scale-dot-white-shadow: 0 0 0 1px rgba(0,0,0,0.2);
      --scale-dot-black: #2aa198;
      --scale-dot-black-shadow: 0 0 0 1px rgba(255,255,255,0.45);
    }
    :root[data-theme="cobalt"]{
      --active: #4ea3ff;
      --bg: #071225;
      --text: #e3ecf8;
      --muted-text: #b8c7de;
      --small-text: #9bb0c9;
      --panel-bg: #0c1931;
      --panel-border: #132646;
      --panel-shadow: 0 1px 0 #050c1a inset, 0 0 0 1px #132646;
      --control-bg: #0b1730;
      --control-border: #132646;
      --control-text: #e9f1ff;
      --control-strong-bg: #10213f;
      --control-strong-border: #1b3470;
      --control-strong-shadow: 0 0 0 1px #1b3470, 0 2px 6px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(255,255,255,0.04);
      --kbd-wrap-bg: #0b1730;
      --kbd-wrap-border: #132646;
      --kbd-wrap-shadow: 0 1px 0 #050c1a inset, 0 0 0 1px #132646;
      --banner-bg: linear-gradient(90deg, #10213f, #0b1730);
      --banner-border: #1b3470;
      --banner-text: #cfe3ff;
      --banner-strong: #78b7ff;
      --btn-bg: #10213f;
      --btn-border: #1b3470;
      --pill-border: #1b3470;
      --pill-text: #9eb6da;
      --log-bg: #0b1730;
      --log-border: #132646;
      --row-icon-bg: #10213f;
      --row-icon-border: #1b3470;
      --row-icon-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);

      --white-top: #f7fbff;
      --white-bottom: #e3edf8;
      --white-border: #a4b6cc;
      --white-border-bottom: #788aa2;
      --white-label: #2c3e56;
      --white-active-top: #e7f4ff;
      --white-active-bottom: #d9ecff;

      --black-top: #0a1321;
      --black-bottom: #182a45;
      --black-border: #08111b;
      --black-border-bottom: #04070c;
      --black-label: #dbe7fb;
      --black-active-top: #13233a;
      --black-active-bottom: #244269;
      --black-shadow: inset 0 -4px 0 rgba(255,255,255,0.06), 0 6px 10px rgba(0,0,0,0.4);

      --scale-dot-white: #4ea3ff;
      --scale-dot-white-shadow: 0 0 0 1px rgba(0,0,0,0.25);
      --scale-dot-black: #8ad1ff;
      --scale-dot-black-shadow: 0 0 0 1px rgba(255,255,255,0.55);
    }
    :root[data-theme="paper"]{
      --active: #c77d2f;
      --bg: #f6f0e6;
      --text: #3b342c;
      --muted-text: #5a5147;
      --small-text: #756a5f;
      --panel-bg: #efe6d6;
      --panel-border: #d6c9b6;
      --panel-shadow: 0 1px 0 #e1d6c6 inset, 0 0 0 1px #d6c9b6;
      --control-bg: #f3ecdf;
      --control-border: #d6c9b6;
      --control-text: #3b342c;
      --control-strong-bg: #e7dcc8;
      --control-strong-border: #cbbba3;
      --control-strong-shadow: 0 0 0 1px #cbbba3, 0 2px 6px rgba(94,83,69,0.15), inset 0 0 0 1px rgba(255,255,255,0.5);
      --kbd-wrap-bg: #f3ecdf;
      --kbd-wrap-border: #d6c9b6;
      --kbd-wrap-shadow: 0 1px 0 #e1d6c6 inset, 0 0 0 1px #d6c9b6;
      --banner-bg: linear-gradient(90deg, #f0e3d0, #e7d9c3);
      --banner-border: #cbbba3;
      --banner-text: #4a4036;
      --banner-strong: #b16a21;
      --btn-bg: #e7dcc8;
      --btn-border: #cbbba3;
      --pill-border: #cbbba3;
      --pill-text: #6d6054;
      --log-bg: #f3ecdf;
      --log-border: #d6c9b6;
      --row-icon-bg: #e7dcc8;
      --row-icon-border: #cbbba3;
      --row-icon-shadow: inset 0 0 0 1px rgba(255,255,255,0.45);

      --white-top: #fffdf8;
      --white-bottom: #f3ece1;
      --white-border: #bbaa93;
      --white-border-bottom: #7f6e5a;
      --white-label: #4a4036;
      --white-active-top: #fff4dc;
      --white-active-bottom: #f2dfbf;

      --black-top: #3b342c;
      --black-bottom: #2a241f;
      --black-border: #241f1a;
      --black-border-bottom: #16120f;
      --black-label: #efe7de;
      --black-active-top: #4a4036;
      --black-active-bottom: #3a322b;
      --black-shadow: inset 0 -4px 0 rgba(255,255,255,0.04), 0 6px 10px rgba(0,0,0,0.25);

      --scale-dot-white: #c77d2f;
      --scale-dot-white-shadow: 0 0 0 1px rgba(0,0,0,0.2);
      --scale-dot-black: #2f8aa0;
      --scale-dot-black-shadow: 0 0 0 1px rgba(255,255,255,0.45);
    }
    :root[data-theme="forest"]{
      --active: #3fbf8f;
      --bg: #0b1b16;
      --text: #e0f3ec;
      --muted-text: #b5d3c8;
      --small-text: #9ab8ad;
      --panel-bg: #10241d;
      --panel-border: #1b3a2f;
      --panel-shadow: 0 1px 0 #081410 inset, 0 0 0 1px #1b3a2f;
      --control-bg: #0f211a;
      --control-border: #1b3a2f;
      --control-text: #e8f6f0;
      --control-strong-bg: #143026;
      --control-strong-border: #1f4a3b;
      --control-strong-shadow: 0 0 0 1px #1f4a3b, 0 2px 6px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(255,255,255,0.05);
      --kbd-wrap-bg: #0f211a;
      --kbd-wrap-border: #1b3a2f;
      --kbd-wrap-shadow: 0 1px 0 #081410 inset, 0 0 0 1px #1b3a2f;
      --banner-bg: linear-gradient(90deg, #143026, #0f211a);
      --banner-border: #1f4a3b;
      --banner-text: #d4ede4;
      --banner-strong: #72e0b8;
      --btn-bg: #143026;
      --btn-border: #1f4a3b;
      --pill-border: #1f4a3b;
      --pill-text: #9fc3b6;
      --log-bg: #0f211a;
      --log-border: #1b3a2f;
      --row-icon-bg: #143026;
      --row-icon-border: #1f4a3b;
      --row-icon-shadow: inset 0 0 0 1px rgba(255,255,255,0.07);

      --white-top: #f3fbf8;
      --white-bottom: #e3f0ea;
      --white-border: #a4bfb4;
      --white-border-bottom: #6f8e82;
      --white-label: #2f4a40;
      --white-active-top: #e2fff2;
      --white-active-bottom: #d4f7e7;

      --black-top: #0c1914;
      --black-bottom: #1a2e27;
      --black-border: #0a1511;
      --black-border-bottom: #030806;
      --black-label: #d4efe6;
      --black-active-top: #12352c;
      --black-active-bottom: #1e4b3f;
      --black-shadow: inset 0 -4px 0 rgba(255,255,255,0.05), 0 6px 10px rgba(0,0,0,0.4);

      --scale-dot-white: #3fbf8f;
      --scale-dot-white-shadow: 0 0 0 1px rgba(0,0,0,0.25);
      --scale-dot-black: #7fe3c3;
      --scale-dot-black-shadow: 0 0 0 1px rgba(255,255,255,0.55);
    }
    :root[data-theme="sunset"]{
      --active: #ff7a59;
      --bg: #1a0f1f;
      --text: #f4e8ef;
      --muted-text: #d7b9c8;
      --small-text: #c1a1b3;
      --panel-bg: #231328;
      --panel-border: #3a1b3f;
      --panel-shadow: 0 1px 0 #120a15 inset, 0 0 0 1px #3a1b3f;
      --control-bg: #221025;
      --control-border: #3a1b3f;
      --control-text: #f7eef4;
      --control-strong-bg: #311739;
      --control-strong-border: #4a2454;
      --control-strong-shadow: 0 0 0 1px #4a2454, 0 2px 6px rgba(0,0,0,0.45), inset 0 0 0 1px rgba(255,255,255,0.05);
      --kbd-wrap-bg: #221025;
      --kbd-wrap-border: #3a1b3f;
      --kbd-wrap-shadow: 0 1px 0 #120a15 inset, 0 0 0 1px #3a1b3f;
      --banner-bg: linear-gradient(90deg, #311739, #221025);
      --banner-border: #4a2454;
      --banner-text: #f0dbe6;
      --banner-strong: #ffb28f;
      --btn-bg: #311739;
      --btn-border: #4a2454;
      --pill-border: #4a2454;
      --pill-text: #cda6bb;
      --log-bg: #221025;
      --log-border: #3a1b3f;
      --row-icon-bg: #311739;
      --row-icon-border: #4a2454;
      --row-icon-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);

      --white-top: #fff2f0;
      --white-bottom: #f5dedb;
      --white-border: #c6a4a0;
      --white-border-bottom: #8c6c6a;
      --white-label: #4a3b3f;
      --white-active-top: #ffe2d8;
      --white-active-bottom: #f6cfc3;

      --black-top: #24131c;
      --black-bottom: #3a1b2b;
      --black-border: #1c0f17;
      --black-border-bottom: #09060b;
      --black-label: #f1dfe8;
      --black-active-top: #3b2031;
      --black-active-bottom: #5a2b40;
      --black-shadow: inset 0 -4px 0 rgba(255,255,255,0.05), 0 6px 10px rgba(0,0,0,0.45);

      --scale-dot-white: #ff7a59;
      --scale-dot-white-shadow: 0 0 0 1px rgba(0,0,0,0.25);
      --scale-dot-black: #ffb28f;
      --scale-dot-black-shadow: 0 0 0 1px rgba(255,255,255,0.5);
    }
    :root[data-theme="studio"]{
      --active: #51d0c9;
      --bg: #101215;
      --text: #e6ecef;
      --muted-text: #c1cbd2;
      --small-text: #9aa7b0;
      --panel-bg: #14181c;
      --panel-border: #202831;
      --panel-shadow: 0 1px 0 #0a0c0e inset, 0 0 0 1px #202831;
      --control-bg: #111519;
      --control-border: #202831;
      --control-text: #e6f2f2;
      --control-strong-bg: #1b222a;
      --control-strong-border: #2c3844;
      --control-strong-shadow: 0 0 0 1px #2c3844, 0 2px 6px rgba(0,0,0,0.4), inset 0 0 0 1px rgba(255,255,255,0.04);
      --kbd-wrap-bg: #111519;
      --kbd-wrap-border: #202831;
      --kbd-wrap-shadow: 0 1px 0 #0a0c0e inset, 0 0 0 1px #202831;
      --banner-bg: linear-gradient(90deg, #1b222a, #111519);
      --banner-border: #2c3844;
      --banner-text: #d9ecec;
      --banner-strong: #7ee7e0;
      --btn-bg: #1b222a;
      --btn-border: #2c3844;
      --pill-border: #2c3844;
      --pill-text: #a3b7bf;
      --log-bg: #111519;
      --log-border: #202831;
      --row-icon-bg: #1b222a;
      --row-icon-border: #2c3844;
      --row-icon-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);

      --white-top: #f7fbfb;
      --white-bottom: #e3ecef;
      --white-border: #a5b4bd;
      --white-border-bottom: #72818a;
      --white-label: #2d3a42;
      --white-active-top: #e6fcfb;
      --white-active-bottom: #d7f1ef;

      --black-top: #10161b;
      --black-bottom: #1f2a33;
      --black-border: #0d1216;
      --black-border-bottom: #05080a;
      --black-label: #d7e6ea;
      --black-active-top: #1a2a31;
      --black-active-bottom: #2e3f47;
      --black-shadow: inset 0 -4px 0 rgba(255,255,255,0.05), 0 6px 10px rgba(0,0,0,0.4);

      --scale-dot-white: #51d0c9;
      --scale-dot-white-shadow: 0 0 0 1px rgba(0,0,0,0.25);
      --scale-dot-black: #9cf2ea;
      --scale-dot-black-shadow: 0 0 0 1px rgba(255,255,255,0.55);
    }
    body{ font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; margin:0; padding:18px; background:var(--bg); color:var(--text); }
    h1{ font-size:20px; margin:0 0 10px; letter-spacing:0.3px; }
    .panel{ display:flex; flex-wrap:wrap; gap:12px 18px; align-items:center; padding:12px; border-radius:12px; background:var(--panel-bg); box-shadow: var(--panel-shadow); }
    .panel label{ font-size:14px; color:var(--muted-text); }
    select, input[type="range"], button{ background:var(--control-bg); color:var(--control-text); border:1px solid var(--control-border); border-radius:10px; padding:8px 10px; font-size:14px; }
    select{ min-width:220px; }
    .mode{ display:flex; gap:10px; align-items:center; }
    .mode input{ accent-color:var(--active); }
    .kbd-wrap{ position:relative; margin-top:14px; padding:14px; border-radius:14px; background:var(--kbd-wrap-bg); box-shadow: var(--kbd-wrap-shadow); }
    .keyboard{
      position:relative;
      width: calc(28 * var(--white-w));
      height: var(--white-h);
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
      -webkit-tap-highlight-color: transparent;
      touch-action:none;
    }
    .keyboard *{
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
    }

    /* White keys */
    .white{
      position:relative; display:inline-block; vertical-align:top;
      width:var(--white-w); height:var(--white-h);
      background:linear-gradient(var(--white-top), var(--white-bottom));
      border:1px solid var(--white-border); border-bottom:3px solid var(--white-border-bottom); border-radius:0 0 6px 6px;
      box-sizing:border-box; margin:0; cursor:pointer; 
    }
    .white .label{ position:absolute; bottom:6px; left:0; right:0; text-align:center; font: 700 11px/1.1 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; color:var(--white-label); pointer-events:none; }
    .white.active{ outline:2px solid var(--active); background:linear-gradient(var(--white-active-top), var(--white-active-bottom)); }

    /* Black keys */
    .black{
      position:absolute; top:0; width:var(--black-w); height:var(--black-h);
      background:linear-gradient(var(--black-top), var(--black-bottom));
      border:1px solid var(--black-border); border-bottom:3px solid var(--black-border-bottom); border-radius:0 0 5px 5px;
      transform:translateX(-50%); z-index:5; cursor:pointer;
      box-shadow: var(--black-shadow);
    }
    .black .label{ position:absolute; bottom:8px; left:0; right:0; text-align:center; font:700 10px/1.1 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:var(--black-label); pointer-events:none; }
    .black.active{ outline:2px solid var(--active); background:linear-gradient(var(--black-active-top), var(--black-active-bottom)); }

    .row{ display:flex; gap:10px; align-items:center; }
    .spacer{ flex:1; }
    .pill{ padding:4px 8px; font-size:12px; border:1px solid var(--pill-border); border-radius:999px; color:var(--pill-text); }
    .small{ font-size:12px; color:var(--small-text); }
    .hidden{ display:none; }
    #testLog{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; line-height:1.35; white-space:pre-wrap; background:var(--log-bg); border:1px solid var(--log-border); border-radius:10px; padding:8px; max-height:180px; overflow:auto; }
    .ok{ color:#8ae234; }
    .fail{ color:#ff6b6b; }

    /* Banner + buttons */
    .banner{ display:flex; flex-wrap:wrap; align-items:center; gap:10px; padding:10px 12px; border-radius:10px; margin:8px 0 12px; background:var(--banner-bg); border:1px solid var(--banner-border); color:var(--banner-text); }
    .banner strong{ color:var(--banner-strong); }
    .btn{ border-radius:999px; padding:6px 10px; border:1px solid var(--btn-border); background:var(--btn-bg); color:inherit; cursor:pointer; }
    .btn:hover{ filter:brightness(1.15); }
    /* Emphasize controls in the main panel without changing section backgrounds */
    .control-panel select,
    .control-panel button,
    .control-panel input[type="range"]{
      background:var(--control-strong-bg);             /* slightly lighter for contrast */
      border-color:var(--control-strong-border);       /* higher contrast border */
      box-shadow: var(--control-strong-shadow);
    }
    .control-panel button{ font-weight:600; }
    .control-panel select:hover,
    .control-panel button:hover{ filter:brightness(1.08); }
    .control-panel select:focus-visible,
    .control-panel button:focus-visible,
    .control-panel input[type="range"]:focus-visible{
      outline:2px solid var(--active);
      outline-offset:2px;
    }
    /* Scale markers (small blue dot on keys) */
    .scale-dot{ position:absolute; width:8px; height:8px; border-radius:50%; pointer-events:none; opacity:0.9; }
    .white .scale-dot{ bottom:28px; top:auto; left:50%; transform:translateX(-50%); background:var(--scale-dot-white); box-shadow:var(--scale-dot-white-shadow); }
    .black .scale-dot{ top:6px; left:50%; transform:translateX(-50%); background:var(--scale-dot-black); box-shadow:var(--scale-dot-black-shadow); }
    /* Row icons */
    .row-icon{ font-size:16px; line-height:1; display:inline-flex; align-items:center; justify-content:center; width:24px; height:24px; border-radius:999px; background:var(--row-icon-bg); border:1px solid var(--row-icon-border); box-shadow: var(--row-icon-shadow); }
  </style>
  <!-- NOTE: We load soundfont-player and WebAudioFont dynamically via CDN with readiness checks. -->
</head>
<body>
  <h1>Virtual Keyboard ‚Äî 4 Octaves ‚Ä¢ Normal & Latch Modes ‚Ä¢ Sampled Instruments & Pure Tones</h1>

  <div id="fallbackBanner" class="banner hidden" role="status" aria-live="polite">
    <span>üéµ</span>
    <span id="bannerMsg"><strong>Notice.</strong> Using fallback engine.</span>
    <div style="flex-basis:100%; height:0"></div>
    <div>
      <span class="small" style="margin-right:6px">Engine (temporary):</span>
      <button class="btn" data-engine="sf">Try SoundFont</button>
      <button class="btn" data-engine="waf">Try WebAudioFont</button>
      <button class="btn" data-engine="osc">Use Pure Tones</button>
      <button class="btn" id="hideBannerBtn" title="Hide troubleshooting controls">Hide</button>
    </div>
  </div>

  <!-- Row: Sound -->
  <div id="panelSound" class="panel control-panel">
    <span class="row-icon" aria-hidden="true">üéπ</span>
    <label>Sound source:
      <select id="soundSelect" title="Choose a sampled instrument or a pure tone">
        <optgroup label="Sampled instruments (SoundFont)">
          <option value="sf:acoustic_grand_piano" selected>Piano (grand)</option>
          <option value="sf:violin">Violin</option>
          <option value="sf:flute">Flute</option>
          <option value="sf:nylon_guitar">Guitar (nylon)</option>
          <option value="sf:trumpet">Trumpet</option>
          <option value="sf:alto_sax">Alto Sax</option>
          <option value="sf:music_box">Music Box</option>
          <option value="sf:celesta">Celesta</option>
        </optgroup>
        <optgroup label="Sampled instruments (WebAudioFont)">
          <option value="waf:acoustic_grand_piano">Piano (grand) ‚Äî WAF</option>
          <option value="waf:violin">Violin ‚Äî WAF</option>
          <option value="waf:flute">Flute ‚Äî WAF</option>
          <option value="waf:nylon_guitar">Guitar (nylon) ‚Äî WAF</option>
          <option value="waf:trumpet">Trumpet ‚Äî WAF</option>
          <option value="waf:alto_sax">Alto Sax ‚Äî WAF</option>
          <option value="waf:music_box">Music Box ‚Äî WAF</option>
          <option value="waf:celesta">Celesta ‚Äî WAF</option>
        </optgroup>
        <optgroup label="Pure tones (oscillator)">
          <option value="osc:sine">Pure: Sine</option>
          <option value="osc:triangle">Pure: Triangle</option>
          <option value="osc:square">Pure: Square</option>
          <option value="osc:sawtooth">Pure: Sawtooth</option>
        </optgroup>
      </select>
    </label>

    <label>Volume
      <input id="vol" type="range" min="0" max="1" step="0.01" value="0.85" />
    </label>

    <label>Theme
      <select id="themeSelect" title="Change the UI theme">
        <option value="midnight" selected>Midnight</option>
        <option value="solarized-dark">Solarized Dark</option>
        <option value="solarized-light">Solarized Light</option>
        <option value="studio">Studio</option>
        <option value="cobalt">Cobalt</option>
        <option value="forest">Forest</option>
        <option value="sunset">Sunset</option>
        <option value="paper">Paper</option>
      </select>
    </label>

    <button id="stopAll">Stop All</button>
    <span id="status" class="small" aria-live="polite"></span>
  </div>

  <!-- Row: Play -->
  <div id="panelPlay" class="panel control-panel">
    <span class="row-icon" aria-hidden="true">‚ñ∂Ô∏è</span>
    <div class="mode" title="How notes stop">
      <label><input type="radio" name="mode" value="normal" checked> Normal</label>
      <label><input type="radio" name="mode" value="latch"> Latch sustain</label>
      <span class="pill">Normal: short click rings; hold = sustain while held</span>
      <span class="pill">Latch: click to start, click again to stop</span>
    </div>

    <label>Default length (Normal)
      <input id="defaultLen" type="range" min="0.3" max="3.0" step="0.1" value="1.5" />
    </label>

    <label>Home row octave
      <input id="homeOct" type="number" min="2" max="5" step="1" value="4" />
    </label>

    <label>Bottom row offset
      <select id="bottomOffset">
        <option value="0">Same as home</option>
        <option value="-1" selected>Home - 1</option>
        <option value="-2">Home - 2</option>
      </select>
    </label>

    <button id="btnSelfTest" title="Run quick diagnostics">Run self‚Äëtest</button>
  </div>

  <!-- Row: Guide -->
  <div id="panelGuide" class="panel control-panel">
    <span class="row-icon" aria-hidden="true">üéº</span>
    <label>Scale type
      <select id="scaleType">
        <option value="none" selected>No scale</option>
        <option value="major">Major</option>
        <option value="minor">Minor</option>
      </select>
    </label>

    <label>Scale key
      <select id="scaleKey">
        <option value="C" selected>C</option>
        <option value="C#">C#</option>
        <option value="D">D</option>
        <option value="D#">D#</option>
        <option value="E">E</option>
        <option value="F">F</option>
        <option value="F#">F#</option>
        <option value="G">G</option>
        <option value="G#">G#</option>
        <option value="A">A</option>
        <option value="A#">A#</option>
        <option value="B">B</option>
      </select>
    </label>

    <span class="pill">‚óè scale notes</span>
    <label class="mode" title="Map A..J and Z..M to 1‚Äì7 of the chosen scale">
      <input id="scaleLock" type="checkbox" checked /> Scale Lock (A..J = 1‚Äì7)
    </label>
  </div>

  <div class="kbd-wrap">
    <div id="keyboard" class="keyboard" aria-label="Four-octave keyboard from C2 to B5"></div>
  </div>

  <!-- Row: QWERTY Help -->
  <div id="panelHelp" class="panel control-panel" aria-live="polite">
    <span class="row-icon" aria-hidden="true">‚å®Ô∏è</span>
    <button id="toggleGuide" class="btn" aria-expanded="false" aria-controls="qwertyGuide">Show QWERTY Guide</button>
    <div id="qwertyGuide" class="small hidden" style="flex-basis:100%">
      <div style="margin:6px 0"><strong>Home row (A S D F G H J)</strong>: degrees 1‚Äì7 of the selected scale; defaults to octave 4 (adjust with the Home row octave control or the [ and ] keys).</div>
      <div style="margin:6px 0"><strong>Bottom row (Z X C V B N M)</strong>: same degrees in a lower register; defaults to one octave down (C3) and can be shifted with the Bottom row offset control.</div>
      <div style="margin:6px 0"><strong>Accidentals (W E T Y U)</strong>: black keys relative to the top-row root (e.g., C# D# F# G# A#).</div>
      <div style="margin:6px 0">Use [ and ] to shift the rows down or up an octave, and &#92; to jump back to the defaults.</div>
      <div style="margin:6px 0">Letters cover C2 up through C5 depending on your row offsets. Scale Lock aligns letters to your chosen key/type.</div>
      <div id="qwertyExamples" class="small" style="margin-top:8px"></div>
      <div id="chromaticTip" class="small" style="margin-top:6px"></div>
    </div>
  </div>

  <div class="panel" style="margin-top:12px">
    <div class="small" style="margin-bottom:6px">Diagnostics log</div>
    <div id="testLog" aria-live="polite"></div>
  </div>

<script>
'use strict';
(function(){
  // =============================
  // Utilities & dynamic loader
  // =============================
  const CDN_SOURCES = [
    'https://unpkg.com/soundfont-player@0.15.7/dist/soundfont-player.min.js',
    'https://cdn.jsdelivr.net/npm/soundfont-player@0.15.7/dist/soundfont-player.min.js'
  ];
  const SF_GLOBAL = 'Soundfont';

  function log(msg, ok=true){
    const el = document.getElementById('testLog');
    const p = document.createElement('div');
    p.className = ok ? 'ok' : 'fail';
    p.textContent = (ok ? '‚úî ' : '‚úñ ') + msg;
    el.appendChild(p);
    el.scrollTop = el.scrollHeight;
  }

  function showStatus(text){
    const statusEl = document.getElementById('status');
    statusEl.textContent = text;
    clearTimeout(showStatus._t);
    showStatus._t = setTimeout(()=>{ statusEl.textContent=''; }, 2500);
  }

  function showBanner(msg){
    const b = document.getElementById('fallbackBanner');
    document.getElementById('bannerMsg').innerHTML = `<strong>Notice.</strong> ${msg}`;
    b.classList.remove('hidden');
  }
  function hideBanner(){
    document.getElementById('fallbackBanner').classList.add('hidden');
  }

  function setDropdownValue(val){
    const sel = document.getElementById('soundSelect');
    sel.value = val; // programmatic change; no event dispatch
  }

  function loadScript(src, timeoutMs=8000){
    return new Promise((resolve, reject)=>{
      const s = document.createElement('script');
      s.src = src;
      s.async = true;
      let done = false;
      s.onload = ()=>{ if(done) return; done = true; resolve(); };
      s.onerror = ()=>{ if(done) return; done = true; reject(new Error('Failed to load '+src)); };
      document.head.appendChild(s);
      setTimeout(()=>{ if(!done){ done = true; reject(new Error('Timeout loading '+src)); } }, timeoutMs);
    });
  }

  async function ensureSoundfont(){
    if(window[SF_GLOBAL]) return window[SF_GLOBAL];
    for(const src of CDN_SOURCES){
      try{
        await loadScript(src);
        if(window[SF_GLOBAL]){ log('soundfont-player loaded from '+src); return window[SF_GLOBAL]; }
      }catch(err){ log(err.message, false); }
    }
    log('soundfont-player unavailable', false);
    return null;
  }

  function switchToOscillatorFallback(message){
    sourceKind = 'osc';
    sourceName = 'sine';
    setDropdownValue('osc:sine');
    showBanner(message || 'Switched to <em>Pure: Sine</em> as a fallback.');
    showStatus('Using oscillator fallback');
  }

  // =============================
  // WebAudioFont dynamic loader (no install)
  // =============================
  const WAF_CDN_SOURCES = [
    'https://cdn.jsdelivr.net/npm/webaudiofont@3.0.4/npm/dist/WebAudioFontPlayer.js',
    'https://surikov.github.io/webaudiofont/npm/dist/WebAudioFontPlayer.js'
  ];
  const WAF_BASE = 'https://surikov.github.io/webaudiofontdata/sound/';
  const WAF_VARIANT = 'GeneralUserGS_sf2_file';
  const WAF_PRESETS = {
    acoustic_grand_piano: { code: '0000', title: 'Acoustic Grand Piano' },
    violin:                { code: '0400', title: 'Violin' },
    flute:                 { code: '0730', title: 'Flute' },
    nylon_guitar:          { code: '0240', title: 'Acoustic Guitar (nylon)' },
    trumpet:               { code: '0560', title: 'Trumpet' },
    alto_sax:              { code: '0650', title: 'Alto Sax' },
    music_box:             { code: '0100', title: 'Music Box' },
    celesta:               { code: '0080', title: 'Celesta' }
  };

  async function ensureWebAudioFont(){
    if(window.WebAudioFontPlayer) return window.WebAudioFontPlayer;
    for(const src of WAF_CDN_SOURCES){
      try{
        await loadScript(src);
        if(window.WebAudioFontPlayer){ log('WebAudioFontPlayer loaded from '+src); return window.WebAudioFontPlayer; }
      }catch(err){ log(err.message, false); }
    }
    log('WebAudioFontPlayer unavailable', false);
    return null;
  }

  async function maybeLoadWAFInstrument(name){
    const WAF = await ensureWebAudioFont();
    if(!WAF){ return null; }
    const map = WAF_PRESETS[name];
    if(!map){ log('No WebAudioFont mapping for "'+name+'"', false); return null; }
    if(!wafPlayer) wafPlayer = new window.WebAudioFontPlayer();
    const code = map.code;
    const file = `${code}_${WAF_VARIANT}.js`;
    const varName = `_tone_${code}_${WAF_VARIANT}`;
    return new Promise((resolve)=>{
      try{
        wafPlayer.loader.startLoad(ctx, WAF_BASE + file, varName);
        wafPlayer.loader.waitLoad(function(){
          wafPresetVar = varName;
          hideBanner();
          log(`WAF instrument loaded: ${name} ‚Üí ${varName}`);
          resolve(wafPlayer);
        });
      }catch(err){
        log('WebAudioFont load failed: '+err.message, false);
        resolve(null);
      }
    });
  }

  // =============================
  // Audio graph
  // =============================
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const ctx = new AudioContext();
  const master = ctx.createGain();
  master.gain.value = 0.85;
  master.connect(ctx.destination);

  function ensureAudio(){ if(ctx.state !== 'running') ctx.resume(); }
  function now(){ return ctx.currentTime; }

  // =============================
  // Build keyboard (C3..B5)
  // =============================
  const startMIDI = 36; // C2
  const endMIDI   = 83; // B5
  const WHITE_W = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--white-w'));

  const keyboard = document.getElementById('keyboard');
  const noteOrder = [];

  function midiToNote(m){
    const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const name = names[m % 12];
    const octave = Math.floor(m/12) - 1;
    return name + octave;
  }
  function isSharpName(n){ return n.includes('#'); }
  function midiToFreq(m){ return 440 * Math.pow(2, (m-69)/12); }
  function noteNameToMidi(name){
    const map = {C:0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11};
    const m = map[name.replace(/-?\d+$/, '').toUpperCase()];
    const oct = parseInt(name.match(/(-?\d+)$/)[1], 10);
    return (oct + 1) * 12 + m;
  }

  for(let m=startMIDI; m<=endMIDI; m++){
    const note = midiToNote(m);
    const sharp = isSharpName(note);
    noteOrder.push({m, note, sharp});
  }

  // White keys first
  let whiteCount = 0;
  noteOrder.forEach(n=>{
    if(!n.sharp){
      const key = document.createElement('div');
      key.className = 'white';
      key.dataset.note = n.note;
      key.style.width = 'var(--white-w)';
      key.innerHTML = `<div class="label">${n.note}</div>`;
      keyboard.appendChild(key);
      n.whiteIndex = whiteCount;
      whiteCount++;
    }
  });
  // Black keys second (positioned between)
  let lastWhiteIndex = -1; whiteCount = 0;
  noteOrder.forEach(n=>{
    if(!n.sharp){ lastWhiteIndex = whiteCount; whiteCount++; return; }
    const black = document.createElement('div');
    black.className = 'black';
    black.dataset.note = n.note;
    black.innerHTML = `<div class="label">${n.note}</div>`;
    // Center the black key exactly on the boundary between the
    // last white key and the next white key. Since `whiteCount`
    // has been incremented for each preceding white, its value
    // represents the boundary index from the left.
    const left = whiteCount * WHITE_W;
    black.style.left = left + 'px';
    keyboard.appendChild(black);
  });

  // =============================
  // State & controls
  // =============================
  let mode = 'normal'; // 'normal' | 'latch'
  let sourceKind = 'sf';
  let sourceName = 'acoustic_grand_piano'; // sf instrument name OR oscillator type
  let sfPlayer = null; // soundfont-player instrument
  let wafPlayer = null, wafPresetVar = null; // WebAudioFont state
  const active = new Map(); // note -> { type, ... }
  const keysDown = new Set(); // track physical keys to avoid repeat retrigger

  const volEl = document.getElementById('vol');
  const defaultLenEl = document.getElementById('defaultLen');
  const soundSel = document.getElementById('soundSelect');
  const themeSelect = document.getElementById('themeSelect');
  const scaleKeyEl = document.getElementById('scaleKey');
  const scaleTypeEl = document.getElementById('scaleType');
  const scaleLockEl = document.getElementById('scaleLock');
  const homeOctEl = document.getElementById('homeOct');
  const bottomOffsetEl = document.getElementById('bottomOffset');
  const toggleGuideBtn = document.getElementById('toggleGuide');
  const qwertyGuide = document.getElementById('qwertyGuide');
  const qwertyExamples = document.getElementById('qwertyExamples');
  const chromaticTip = document.getElementById('chromaticTip');

  // =============================
  // Theme support
  // =============================
  const THEME_STORAGE_KEY = 'vk_theme';
  const THEME_OPTIONS = new Set([
    'midnight',
    'solarized-dark',
    'solarized-light',
    'studio',
    'cobalt',
    'forest',
    'sunset',
    'paper'
  ]);

  function applyTheme(next, persist=true){
    const theme = THEME_OPTIONS.has(next) ? next : 'midnight';
    document.documentElement.setAttribute('data-theme', theme);
    if(themeSelect) themeSelect.value = theme;
    if(persist){
      try{ localStorage.setItem(THEME_STORAGE_KEY, theme); }catch(_){ }
    }
  }

  let savedTheme = 'midnight';
  try{
    const storedTheme = localStorage.getItem(THEME_STORAGE_KEY);
    if(storedTheme) savedTheme = storedTheme;
  }catch(_){ }
  applyTheme(savedTheme, false);

  if(themeSelect){
    themeSelect.addEventListener('change', ()=>{
      applyTheme(themeSelect.value);
      const label = themeSelect.options[themeSelect.selectedIndex]?.textContent || themeSelect.value;
      showStatus(`Theme: ${label}`);
    });
  }

  // =============================
  // QWERTY keyboard metadata & octave state
  // =============================
  const HOME_KEYS = ['a','s','d','f','g','h','j'];       // degrees 1..7
  const BOTTOM_KEYS = ['z','x','c','v','b','n','m'];     // lower register degrees 1..7
  const ACC_KEYS = ['w','e','t','y','u'];                // black keys: +1,+3,+6,+8,+10
  const ACC_OFFSETS = [1,3,6,8,10];
  const MIDI_MIN = 36; // C2
  const MIDI_MAX = 83; // B5

  const HOME_OCT_MIN = 2;
  const HOME_OCT_MAX = 5;

  function clampHomeOctave(oct){
    return Math.max(HOME_OCT_MIN, Math.min(HOME_OCT_MAX, oct));
  }

  let parsedHome = homeOctEl ? parseInt(homeOctEl.value, 10) : NaN;
  if(Number.isNaN(parsedHome)) parsedHome = 4;
  let homeOctave = clampHomeOctave(parsedHome);
  if(homeOctEl) homeOctEl.value = String(homeOctave);

  let parsedOffset = bottomOffsetEl ? parseInt(bottomOffsetEl.value, 10) : NaN;
  if(Number.isNaN(parsedOffset)) parsedOffset = -1;
  let bottomRowOffset = parsedOffset;
  if(bottomOffsetEl) bottomOffsetEl.value = String(bottomRowOffset);

  const DEFAULT_HOME_OCT = homeOctave;
  const DEFAULT_BOTTOM_OFFSET = bottomRowOffset;

  function computeBottomOctave(){
    return clampHomeOctave(homeOctave + bottomRowOffset);
  }

  function getOctaveStatusText(){
    const map = buildQwertyMap();
    const topAnchor = map[HOME_KEYS[0]] || '‚Äî';
    const bottomAnchor = map[BOTTOM_KEYS[0]] || '‚Äî';
    return `Home row anchor: ${topAnchor} ‚Ä¢ Bottom row anchor: ${bottomAnchor}`;
  }

  function refreshQwertyLayout(){
    updateQwertyGuide();
    showStatus(getOctaveStatusText());
  }

  function setHomeOctave(oct){
    const clamped = clampHomeOctave(oct);
    if(clamped === homeOctave) return false;
    homeOctave = clamped;
    if(homeOctEl) homeOctEl.value = String(clamped);
    refreshQwertyLayout();
    return true;
  }

  function setBottomRowOffset(offset){
    if(offset === bottomRowOffset) return false;
    bottomRowOffset = offset;
    if(bottomOffsetEl) bottomOffsetEl.value = String(offset);
    refreshQwertyLayout();
    return true;
  }

  function resetRowOffsets(){
    const changedTop = setHomeOctave(DEFAULT_HOME_OCT);
    const changedBottom = setBottomRowOffset(DEFAULT_BOTTOM_OFFSET);
    if(!changedTop && !changedBottom){
      refreshQwertyLayout();
    }
  }
  document.getElementById('stopAll').addEventListener('click', stopAll);
  document.getElementById('btnSelfTest').addEventListener('click', runSelfTest);
  document.getElementById('hideBannerBtn').addEventListener('click', hideBanner);
  document.getElementById('fallbackBanner').addEventListener('click', (e)=>{
    const btn = e.target.closest('button[data-engine]'); if(!btn) return;
    const engine = btn.getAttribute('data-engine');
    forceEngine(engine);
  });

  scaleKeyEl.addEventListener('change', ()=>{
    stopAll();
    applyScaleMarkers();
    refreshQwertyLayout();
  });
  scaleTypeEl.addEventListener('change', ()=>{
    stopAll();
    applyScaleMarkers();
    refreshQwertyLayout();
  });
  scaleLockEl.addEventListener('change', ()=>{
    stopAll();
    const lockMsg = scaleLockEl.checked ? 'Scale Lock: on' : 'Scale Lock: off';
    refreshQwertyLayout();
    showStatus(`${lockMsg} ‚Ä¢ ${getOctaveStatusText()}`);
  });

  volEl.addEventListener('input', () => master.gain.value = parseFloat(volEl.value));
  defaultLenEl.addEventListener('input', ()=> showStatus(`Default ring: ${parseFloat(defaultLenEl.value).toFixed(1)}s`));

  function setMode(val){
    mode = val;
    showStatus(mode === 'latch' ? 'Latch sustain: click toggles on/off' : 'Normal: click rings; hold sustains');
  }
  document.getElementsByName('mode').forEach(r=>{
    r.addEventListener('change', (e)=>{ setMode(e.target.value); });
  });

  soundSel.addEventListener('change', async ()=>{
    // Any sound change should silence current notes to avoid overlap, esp. in latch mode
    stopAll();
    const [kind, name] = soundSel.value.split(':');
    hideBanner();
    sourceKind = kind; sourceName = name;
    if(kind === 'sf'){
      const player = await maybeLoadInstrument(name);
      if(player){
        showStatus(`Instrument: ${name.replace(/_/g,' ')}`);
      } else {
        await fallbackFromFailure('sf', name, 'Could not load the selected SoundFont instrument.');
      }
    } else if(kind === 'waf'){
      const p = await maybeLoadWAFInstrument(name);
      if(p){
        const human = (WAF_PRESETS[name]?.title || name).replace(/_/g,' ');
        showStatus(`WAF: ${human}`);
      } else {
        await fallbackFromFailure('waf', name, 'Could not load the selected WebAudioFont preset.');
      }
    } else {
      showStatus(`Oscillator: ${name}`);
    }
  });

  // =============================
  // Engine toggling (temporary, session-only)
  // =============================
  async function forceEngine(engine){
    // Switching engine should silence current notes first
    stopAll();
    const current = soundSel.value;
    const [, curName] = current.split(':');
    if(engine === 'sf'){
      sourceKind = 'sf'; sourceName = curName && WAF_PRESETS[curName] ? curName : 'acoustic_grand_piano';
      const ok = await maybeLoadInstrument(sourceName);
      if(ok){ setDropdownValue(`sf:${sourceName}`); hideBanner(); showStatus('Engine: SoundFont'); }
      else { await fallbackFromFailure('sf', sourceName, 'SoundFont engine failed.'); }
    } else if(engine === 'waf'){
      sourceKind = 'waf'; sourceName = curName && WAF_PRESETS[curName] ? curName : 'acoustic_grand_piano';
      const ok = await maybeLoadWAFInstrument(sourceName);
      if(ok){ setDropdownValue(`waf:${sourceName}`); hideBanner(); showStatus('Engine: WebAudioFont'); }
      else { await fallbackFromFailure('waf', sourceName, 'WebAudioFont engine failed.'); }
    } else {
      switchToOscillatorFallback('Using pure tones.');
    }
  }

  async function fallbackFromFailure(kind, name, reason){
    // On any engine/preset failure, ensure we stop currently sounding notes
    stopAll();
    if(kind === 'sf'){
      // Try same instrument on WebAudioFont
      const ok = await maybeLoadWAFInstrument(name);
      if(ok){
        setDropdownValue(`waf:${name in WAF_PRESETS ? name : 'acoustic_grand_piano'}`);
        sourceKind = 'waf'; sourceName = name in WAF_PRESETS ? name : 'acoustic_grand_piano';
        showBanner(`${reason} Switched to <em>WebAudioFont</em>. Use buttons to try a different engine.`);
        return;
      }
      // Then pure tones
      switchToOscillatorFallback(`${reason} Switched to <em>Pure: Sine</em>.`);
    } else if(kind === 'waf'){
      // Try SoundFont
      const ok = await maybeLoadInstrument(name);
      if(ok){
        setDropdownValue(`sf:${name}`);
        sourceKind = 'sf'; sourceName = name;
        showBanner(`${reason} Switched to <em>SoundFont</em>. Use buttons to try a different engine.`);
        return;
      }
      switchToOscillatorFallback(`${reason} Switched to <em>Pure: Sine</em>.`);
    }
  }

  // =============================
  // Scale markers (major/minor) ‚Äî unobtrusive dots on keys
  // =============================
  const NOTE_TO_PC = {C:0,'C#':1,D:2,'D#':3,E:4,F:5,'F#':6,G:7,'G#':8,A:9,'A#':10,B:11};
  const SCALE_INTERVALS = {
    major: [0,2,4,5,7,9,11],
    minor: [0,2,3,5,7,8,10] // natural minor
  };

  function computeScaleSet(rootName, type){
    if(!type || type === 'none') return null;
    const root = NOTE_TO_PC[rootName];
    const iv = SCALE_INTERVALS[type];
    if(root === undefined || !iv) return null;
    return new Set(iv.map(i => (root + i) % 12));
  }

  function removeAllScaleDots(){
    keyboard.querySelectorAll('.scale-dot').forEach(el => el.remove());
  }

  function applyScaleMarkers(){
    removeAllScaleDots();
    const type = scaleTypeEl.value;
    const root = scaleKeyEl.value;
    const set = computeScaleSet(root, type);
    if(!set) return; // none
    keyboard.querySelectorAll('[data-note]').forEach(el => {
      const pc = noteNameToMidi(el.dataset.note) % 12;
      if(set.has(pc)){
        if(!el.querySelector('.scale-dot')){
          const dot = document.createElement('div');
          dot.className = 'scale-dot';
          el.appendChild(dot);
        }
      }
    });
  }

  // =============================
  // QWERTY Guide rendering
  // =============================
  function updateQwertyGuide(){
    if(!qwertyGuide || qwertyGuide.classList.contains('hidden')) return;
    const map = buildQwertyMap();
    const seq = (keys)=> keys.map(k=> map[k] || '‚Äî').join(' ');
    const top = seq(HOME_KEYS);
    const bot = seq(BOTTOM_KEYS);
    const acc = seq(ACC_KEYS);
    const topAnchor = map[HOME_KEYS[0]] || '‚Äî';
    const bottomAnchor = map[BOTTOM_KEYS[0]] || '‚Äî';
    qwertyExamples.innerHTML = `
      <div><strong>Top row</strong> A S D F G H J ‚Üí ${top} (starts ${topAnchor})</div>
      <div><strong>Bottom row</strong> Z X C V B N M ‚Üí ${bot} (starts ${bottomAnchor})</div>
      <div><strong>Accidentals</strong> W E T Y U ‚Üí ${acc}</div>
    `;
    if(chromaticTip){
      const chromKeys = ['a','w','s','e','d','f','t','g','y','h','u','j'];
      const chromSeq = chromKeys.map(k => map[k] || '‚Äî').join(' ');
      chromaticTip.textContent = `Chromatic walk (A W S E D F T G Y H U J) ‚Üí ${chromSeq}`;
    }
  }

  toggleGuideBtn.addEventListener('click', ()=>{
    const isHidden = qwertyGuide.classList.toggle('hidden');
    toggleGuideBtn.setAttribute('aria-expanded', String(!isHidden));
    toggleGuideBtn.textContent = isHidden ? 'Show QWERTY Guide' : 'Hide QWERTY Guide';
    updateQwertyGuide();
  });

  if(homeOctEl){
    homeOctEl.addEventListener('change', ()=>{
      const val = parseInt(homeOctEl.value, 10);
      if(Number.isNaN(val)){
        homeOctEl.value = String(homeOctave);
        return;
      }
      setHomeOctave(val);
    });
  }

  if(bottomOffsetEl){
    bottomOffsetEl.addEventListener('change', ()=>{
      const val = parseInt(bottomOffsetEl.value, 10);
      if(Number.isNaN(val)){
        bottomOffsetEl.value = String(bottomRowOffset);
        return;
      }
      setBottomRowOffset(val);
    });
  }

  refreshQwertyLayout();

  // =============================
  // QWERTY keyboard support (scale-aware + Scale Lock)
  // =============================
  function clampToRange(midi){
    // Nudge by octaves into available range if possible
    while(midi < MIDI_MIN) midi += 12;
    while(midi > MIDI_MAX) midi -= 12;
    if(midi < MIDI_MIN || midi > MIDI_MAX) return null;
    return midi;
  }

  function degreeToMidi(rootName, octave, degreeIndex, type){
    const iv = SCALE_INTERVALS[type] || SCALE_INTERVALS.major;
    const rootMidi = noteNameToMidi(`${rootName}${octave}`);
    const offset = iv[Math.max(0, Math.min(6, degreeIndex))];
    return rootMidi + offset;
  }

  function buildQwertyMap(){
    const lockOn = !!scaleLockEl.checked;
    const type = scaleTypeEl.value;
    const root = scaleKeyEl.value;
    const map = {};

    // Anchors
    const anchorTopRoot = lockOn && type !== 'none' ? root : 'C';
    const anchorBotRoot = anchorTopRoot; // same root, lower octave
    const topOct = homeOctave;
    const botOct = computeBottomOctave();

    // Home row (degrees 1..7)
    for(let i=0;i<HOME_KEYS.length;i++){
      const midi = degreeToMidi(anchorTopRoot, topOct, i, type === 'none' ? 'major' : type);
      const clamped = clampToRange(midi);
      if(clamped!=null) map[HOME_KEYS[i]] = midiToNote(clamped);
    }
    // Bottom row (degrees 1..7, lower octave)
    for(let i=0;i<BOTTOM_KEYS.length;i++){
      const midi = degreeToMidi(anchorBotRoot, botOct, i, type === 'none' ? 'major' : type);
      const clamped = clampToRange(midi);
      if(clamped!=null) map[BOTTOM_KEYS[i]] = midiToNote(clamped);
    }
    // Accidentals (chromatic relative to root of the row octave)
    for(let i=0;i<ACC_KEYS.length;i++){
      const midi = noteNameToMidi(`${anchorTopRoot}${topOct}`) + ACC_OFFSETS[i];
      const clamped = clampToRange(midi);
      if(clamped!=null) map[ACC_KEYS[i]] = midiToNote(clamped);
    }
    return map;
  }

  function isTypingInForm(target){
    const el = target;
    if(!el) return false;
    const tag = (el.tagName||'').toLowerCase();
    return tag === 'input' || tag === 'select' || tag === 'textarea' || el.isContentEditable;
  }

  function handleKeyDown(e){
    const k = e.key?.toLowerCase();
    if(!k) return;
    if(e.repeat) { /* rely on keysDown to dedupe */ }
    if(isTypingInForm(e.target)) return;
    if(e.ctrlKey || e.metaKey || e.altKey) return;

    if(k === '['){
      e.preventDefault();
      setHomeOctave(homeOctave - 1);
      return;
    }
    if(k === ']'){
      e.preventDefault();
      setHomeOctave(homeOctave + 1);
      return;
    }
    if(k === '\\'){
      e.preventDefault();
      resetRowOffsets();
      return;
    }

    const map = buildQwertyMap();
    const note = map[k];
    if(!note) return;
    if(keysDown.has(k)) return; // ignore repeats
    keysDown.add(k);
    e.preventDefault();
    if(mode==='latch'){
      if(active.has(note)){
        stopNote(note);
      } else {
        stopAll();
        startNote(note);
      }
    } else {
      startNote(note);
    }
  }

  function handleKeyUp(e){
    const k = e.key?.toLowerCase();
    if(!k) return;
    keysDown.delete(k);
    if(isTypingInForm(e.target)) return;
    const map = buildQwertyMap();
    const note = map[k];
    if(!note) return;
    if(mode==='normal'){
      releaseNormal(note);
    }
    // In latch mode, keyup does nothing (toggle handled on keydown)
  }

  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('keyup', handleKeyUp);

  // =============================
  // Note start/stop
  // =============================
  const MIN_HOLD_MS = 100;
  const LATCH_MAX = 3600; // seconds (effectively indefinite) for sampled engines
  const LATCH_VOICE_SEC = 3.0;   // individual one-shot length used for refiring (sf/waf)
  const LATCH_KEEPALIVE_MS = 2600; // refire interval to keep latched notes audible (sf/waf)

  function setKeyActive(note, on){
    keyboard.querySelectorAll(`[data-note="${note}"]`).forEach(k=>k.classList.toggle('active', !!on));
  }

  function startNote(note){
    ensureAudio();
    const t0 = now();
    if(active.has(note)) stopNote(note, true);

    if(sourceKind === 'waf'){
      if(!wafPlayer || !wafPresetVar){
        // gentle local fallback if preset missing
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = midiToFreq(noteNameToMidi(note));
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0, t0);
        gain.gain.linearRampToValueAtTime(1.0, t0 + 0.01);
        gain.gain.linearRampToValueAtTime(0.7, t0 + 0.12);
        osc.connect(gain).connect(master);
        osc.start(t0);
        active.set(note, { type:'osc', osc, gain, startedAt:t0, timer:null });
      } else {
        const dur = (mode==='latch') ? LATCH_VOICE_SEC : parseFloat(defaultLenEl.value);
        const midi = noteNameToMidi(note);
        const env = wafPlayer.queueWaveTable(ctx, master, window[wafPresetVar], t0, midi, dur, 1.0);
        active.set(note, { type:'waf', env, startedAt:t0, timer:null });
        // Keep-alive for latch (retrigger before natural decay)
        if(mode==='latch'){
          const noteName = note;
          const keepId = setInterval(()=>{
            const d = active.get(noteName);
            if(!d || d.type!=='waf' || !wafPlayer || !wafPresetVar) return;
            try{
              const midi2 = noteNameToMidi(noteName);
              const newEnv = wafPlayer.queueWaveTable(ctx, master, window[wafPresetVar], now(), midi2, LATCH_VOICE_SEC, 1.0);
              try{ d.env.cancel(); }catch(_){}
              d.env = newEnv;
            }catch(_){/* swallow */}
          }, LATCH_KEEPALIVE_MS);
          const d = active.get(noteName); if(d) d.keepAlive = keepId;
        }
      }
    } else if(sourceKind === 'sf' && sfPlayer){
      const dur = (mode==='latch') ? LATCH_VOICE_SEC : parseFloat(defaultLenEl.value);
      const playable = sfPlayer.play(note, t0, { duration: dur, gain: 1.0 });
      active.set(note, { type:'sf', playable, startedAt:t0, timer:null });
      // Keep-alive for latch (retrigger before one-shot sample ends)
      if(mode==='latch'){
        const noteName = note;
        const keepId = setInterval(()=>{
          const d = active.get(noteName);
          if(!d || d.type!=='sf' || !sfPlayer) return;
          try{
            const newPlayable = sfPlayer.play(noteName, now(), { duration: LATCH_VOICE_SEC, gain: 1.0 });
            try{ d.playable.stop(); }catch(_){}
            d.playable = newPlayable;
          }catch(_){/* swallow */}
        }, LATCH_KEEPALIVE_MS);
        const d = active.get(noteName); if(d) d.keepAlive = keepId;
      }
    } else {
      // oscillator baseline (pure tone)
      const osc = ctx.createOscillator();
      osc.type = sourceName; // sine, square, triangle, sawtooth
      osc.frequency.value = midiToFreq(noteNameToMidi(note));
      const gain = ctx.createGain();
      const a=0.01, d=0.08, s=0.75; // simple ADS
      gain.gain.setValueAtTime(0, t0);
      gain.gain.linearRampToValueAtTime(1.0, t0 + a);
      gain.gain.linearRampToValueAtTime(s, t0 + a + d);
      osc.connect(gain).connect(master);
      osc.start(t0);
      active.set(note, { type:'osc', osc, gain, startedAt:t0, timer:null });
    }
    setKeyActive(note, true);
  }

  function stopNote(note){
    const d = active.get(note);
    // clear any latch keep-alive interval
    if(d && d.keepAlive){ clearInterval(d.keepAlive); d.keepAlive = null; }
    if(!d) return;
    const t = now();
    if(d.type === 'osc'){
      const rel = 0.2;
      d.gain.gain.cancelScheduledValues(t);
      d.gain.gain.setValueAtTime(d.gain.gain.value, t);
      d.gain.gain.linearRampToValueAtTime(0, t + rel);
      d.osc.stop(t + rel + 0.02);
    } else if(d.type === 'sf'){
      try{ d.playable.stop(); }catch(_){ }
    } else if(d.type === 'waf'){
      try{ d.env.cancel(); }catch(_){ }
    }
    if(d.timer) clearTimeout(d.timer);
    active.delete(note);
    setKeyActive(note, false);
  }

  function stopAll(){
    keysDown.clear();
    Array.from(active.keys()).forEach(n=>stopNote(n, true));
  }

  function releaseNormal(note){
    const d = active.get(note); if(!d) return;
    const tHeldMs = (now() - d.startedAt) * 1000;
    if(tHeldMs < MIN_HOLD_MS){
      const target = d.startedAt + parseFloat(defaultLenEl.value);
      const ms = Math.max(0, (target - now()) * 1000);
      if(d.timer) clearTimeout(d.timer);
      d.timer = setTimeout(()=> stopNote(note), ms);
    } else {
      stopNote(note);
    }
  }

  function bindKeyEvents(el){
    const note = el.dataset.note;
    el.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      el.setPointerCapture?.(e.pointerId);
      if(mode==='latch'){
        if(active.has(note)){
          // toggle off
          stopNote(note);
        } else {
          // monophonic latch: stop any other sounding notes before starting new
          stopAll();
          startNote(note);
        }
      } else {
        startNote(note);
      }
    });
    el.addEventListener('pointerup', ()=>{ if(mode==='normal') releaseNormal(note); });
    el.addEventListener('pointercancel', ()=>{ if(mode==='normal') releaseNormal(note); });
  }
  keyboard.addEventListener('selectstart', (e)=>{ e.preventDefault(); });
  keyboard.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });
  keyboard.addEventListener('dragstart', (e)=>{ e.preventDefault(); });
  // Hook up key events & initial scale markers
  keyboard.querySelectorAll('[data-note]').forEach(bindKeyEvents);
  // Ensure scale markers render at startup when a scale is chosen later
  applyScaleMarkers();
  // Prepare initial QWERTY guide text (remains hidden until toggled)
  updateQwertyGuide();

  // =============================
  // Instrument loading with guard
  // =============================
  async function maybeLoadInstrument(name){
    const Soundfont = await ensureSoundfont();
    if(!Soundfont){ return null; }
    showStatus('Loading SoundFont instrument‚Ä¶');
    try{
      sfPlayer = await Soundfont.instrument(ctx, name, { soundfont: 'MusyngKite', destination: master });
      hideBanner();
      log(`SoundFont instrument loaded: ${name}`);
      return sfPlayer;
    }catch(err){
      log('SoundFont load failed: '+err.message, false);
      sfPlayer = null;
      return null;
    } finally {
      showStatus('');
    }
  }

  // =============================
  // Self-tests (manual)
  // =============================
  async function runSelfTest(){
    ensureAudio();
    document.getElementById('testLog').textContent='';
    // Test 1: Soundfont global
    const sf = await ensureSoundfont();
    if(sf){ log('Global "Soundfont" is defined'); } else { log('Global "Soundfont" not available', false); }

    // Test 2: Try load default SoundFont instrument
    if(sf){
      const p = await maybeLoadInstrument('acoustic_grand_piano');
      if(p){ log('Loaded "acoustic_grand_piano" via SoundFont successfully'); }
      else { log('Could not load "acoustic_grand_piano" via SoundFont', false); }
    }

    // Test 2b: WebAudioFont availability + load piano
    try{
      const waf = await ensureWebAudioFont();
      if(waf){
        log('WebAudioFontPlayer is defined');
        const ok = await maybeLoadWAFInstrument('acoustic_grand_piano');
        if(ok){
          wafPlayer.queueWaveTable(ctx, master, window[wafPresetVar], now(), 69, 0.25, 0.6);
          log('WebAudioFont A4 test played for 250ms');
        } else {
          log('Could not load WebAudioFont preset for piano', false);
        }
      } else {
        log('WebAudioFontPlayer not available', false);
      }
    }catch(err){ log('WebAudioFont test raised: '+err.message, false); }

    // Test 3: Play A4 briefly via oscillator as baseline
    try{
      const t0 = now();
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = 440;
      const g = ctx.createGain();
      g.gain.value = 0.2; // quiet beep
      osc.connect(g).connect(master);
      osc.start(t0);
      osc.stop(t0 + 0.25);
      log('Oscillator baseline beep (A4) played for 250ms');
    }catch(err){ log('Oscillator failed: '+err.message, false); }

    // Test 4: Latch toggle logic (no exception path)
    try{
      const n = 'C4';
      startNote(n); // start
      stopNote(n);  // stop
      log('Latch/stop logic executed without exception');
    }catch(err){ log('Latch/stop logic raised: '+err.message, false); }

    // Test 5: UI fallback switch visual test
    try{
      switchToOscillatorFallback('Simulated test: fallback UI engaged.');
      const sel = document.getElementById('soundSelect');
      if(sel.value === 'osc:sine') log('Dropdown switched to Pure: Sine (UI fallback)');
      else log('Dropdown did not switch to Pure: Sine', false);
    }catch(err){ log('UI fallback test raised: '+err.message, false); }

    // Test 6: Keyboard range (4 octaves C2..B5)
    try{
      const first = document.querySelector('[data-note="C2"]');
      const last  = document.querySelector('[data-note="B5"]');
      if(first && last) log('DOM keys present: C2 .. B5');
      else log('Expected DOM keys C2 and/or B5 not found', false);
      const whites = document.querySelectorAll('#keyboard .white').length;
      if(whites === 28) log('White key count OK: 28 (4 octaves)');
      else log('White key count expected 21, got ' + whites, false);
    }catch(err){ log('DOM range test raised: ' + err.message, false); }

    // Test 7: Scale markers (C major) ‚Äî C2 and C3 should be marked, C#2 should not
    try{
      const prevKey = scaleKeyEl.value, prevType = scaleTypeEl.value;
      scaleKeyEl.value = 'C'; scaleTypeEl.value = 'major';
      applyScaleMarkers();
      const hasC2  = !!document.querySelector('[data-note="C2"] .scale-dot');
      const hasCs2 = !!document.querySelector('[data-note="C#2"] .scale-dot');
      const hasC3  = !!document.querySelector('[data-note="C3"] .scale-dot');
      if(hasC2 && hasC3 && !hasCs2) log('Scale markers OK for C major (C2 and C3 marked, C#2 not)');
      else log('Scale markers unexpected for C major (C2/'+(hasC2?'‚úì':'‚úó')+', C3/'+(hasC3?'‚úì':'‚úó')+', C#2/'+(hasCs2?'‚úì':'‚úó')+')', false);
      scaleKeyEl.value = prevKey; scaleTypeEl.value = prevType; applyScaleMarkers();
    }catch(err){ log('Scale markers test raised: ' + err.message, false); }

    // Test 8: Latch monophonic replacement
    try{
      setMode('latch');
      // use oscillator engine to avoid async loads
      soundSel.value = 'osc:sine'; soundSel.dispatchEvent(new Event('change'));
      startNote('C4');
      const afterC = active.size;
      startNote('E4');
      const keys = Array.from(active.keys());
      if(afterC === 1 && active.size === 1 && keys[0] === 'E4') log('Latch monophonic OK: E4 replaced C4');
      else log('Latch monophonic unexpected: active=' + JSON.stringify(keys), false);
      stopAll(); setMode('normal');
    }catch(err){ log('Latch monophonic test raised: ' + err.message, false); }

    // Test 9: Stop All silences latched notes
    try{
      setMode('latch');
      startNote('G4');
      stopAll();
      if(active.size === 0) log('Stop All cleared all active notes');
      else log('Stop All did not clear active notes ('+active.size+')', false);
      setMode('normal');
    }catch(err){ log('Stop All test raised: ' + err.message, false); }

    // Test 10: Changing sound source stops current notes
    try{
      setMode('latch');
      soundSel.value = 'osc:sine'; soundSel.dispatchEvent(new Event('change'));
      startNote('A4');
      soundSel.value = 'osc:triangle'; soundSel.dispatchEvent(new Event('change'));
      if(active.size === 0) log('Sound change cleared active notes');
      else log('Sound change did not clear active notes ('+active.size+')', false);
      setMode('normal');
    }catch(err){ log('Sound change test raised: ' + err.message, false); }

    // Test 11: Latch keep-alive scheduled for WAF when available
    try{
      const waf = await ensureWebAudioFont();
      if(waf){
        const ok = await maybeLoadWAFInstrument('acoustic_grand_piano');
        if(ok){
          setMode('latch');
          soundSel.value = 'waf:acoustic_grand_piano';
          const n = 'D4';
          startNote(n);
          const d = active.get(n);
          if(d && d.keepAlive) log('Keep-alive interval present for latched WAF note');
          else log('Keep-alive not set for WAF latched note', false);
          stopNote(n);
          if(!d.keepAlive) log('Keep-alive cleared on stop (WAF)');
          else log('Keep-alive not cleared on stop (WAF)', false);
          setMode('normal');
        } else {
          log('Skipping keep-alive test: WAF preset failed to load');
        }
      } else {
        log('Skipping keep-alive test: WebAudioFont unavailable');
      }
    }catch(err){ log('Keep-alive WAF test raised: ' + err.message, false); }

    // Test 12: Stop All clears keep-alive
    try{
      setMode('latch');
      soundSel.value = 'osc:sine'; soundSel.dispatchEvent(new Event('change'));
      // osc path doesn't need keep-alive, but verify no errors
      startNote('F4');
      stopAll();
      if(active.size === 0) log('Stop All cleared active notes (and any keep-alives)');
      else log('Stop All left active notes', false);
      setMode('normal');
    }catch(err){ log('Stop All keep-alive test raised: ' + err.message, false); }
  }

  // =============================
  // Boot
  // =============================
  (async function boot(){
    // Try SoundFont first ‚Üí if fails, try WAF ‚Üí else pure tones
    const okSF = await maybeLoadInstrument(sourceName);
    if(!okSF){
      const okWAF = await maybeLoadWAFInstrument(sourceName);
      if(okWAF){
        sourceKind = 'waf'; setDropdownValue(`waf:${sourceName}`);
        showBanner('SoundFont unavailable. Switched to <em>WebAudioFont</em>. Use buttons to try a different engine.');
      } else {
        switchToOscillatorFallback('Sampled instruments unavailable. Switched to <em>Pure: Sine</em>.');
      }
    }
  })();

})();
</script>
</body>
</html>
